<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-Assisted Novel Editor</title>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }

        h1, h2, h3 {
            color: #333;
        }

        button {
            padding: 8px 12px;
            margin: 5px 2px;
            cursor: pointer;
            background-color: #5c67f2;
            color: white;
            border: none;
            border-radius: 4px;
        }

        button:hover {
            background-color: #4a54e1;
        }

        button.delete-btn {
            background-color: #e74c3c;
        }
        button.delete-btn:hover {
            background-color: #c0392b;
        }

        button.move-btn {
            background-color: #f39c12;
            font-weight: bold;
            padding: 4px 8px;
            min-width: 30px;
        }
        button.move-btn:hover {
            background-color: #e67e22;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }


        .container {
            max-width: 900px;
            margin: auto;
            background: white;
            padding: 20px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }

        #novelListView, #novelEditorView {
            margin-top: 20px;
        }

        #novelList {
            list-style: none;
            padding: 0;
        }

        #novelList li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #eee;
        }
        #novelList li:last-child {
            border-bottom: none;
        }

        .novel-item-title {
            font-weight: bold;
            cursor: pointer;
        }
        .novel-item-title:hover {
            color: #5c67f2;
        }


        .chapter {
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 20px;
            background-color: #fff;
        }

        .chapter-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        .chapter-title {
            font-size: 1.2em;
            font-weight: bold;
            border: none;
            padding: 5px;
            flex-grow: 1; /* Allow title to take available space */
            margin-right: 10px; /* Space between title and buttons */
        }
        .chapter-title:focus {
            outline: 1px solid #5c67f2;
            background-color: #f0f0ff;
        }

        .chapter-controls button, .beat-controls button {
            margin-left: 5px;
        }

        .scene-beat {
            border: 1px dashed #ddd;
            padding: 10px;
            margin-top: 10px;
            background-color: #f9f9f9;
            border-radius: 4px;
        }

        textarea {
            width: 98%;
            min-height: 60px;
            margin-top: 5px;
            margin-bottom: 5px;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: inherit;
            font-size: 1em;
            resize: vertical; /* Allow vertical resize */
        }

        .beat-text-area {
            min-height: 40px;
        }

        .generated-text-area, .summary-text-area {
            min-height: 80px;
            background-color: #e8f0fe; /* Light blue background for generated content */
        }


        .beat-controls {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            margin-top: 5px;
            flex-wrap: wrap;
        }

        .add-beat-area {
            margin-top: 15px;
            display: flex;
            align-items: center;
        }

        .add-beat-area textarea {
            flex-grow: 1;
            margin-right: 10px;
            min-height: 30px;
        }

        .feedback {
            color: green;
            font-size: 0.9em;
            margin-left: 10px;
            display: inline-block;
            opacity: 0;
            transition: opacity 0.5s ease-out;
        }
        .feedback.show {
            opacity: 1;
        }

        input[type="text"] {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .import-export-area {
            margin: 10px 0;
            padding: 10px;
            background: #f8f8f8;
            border-radius: 4px;
        }

        .import-area {
            display: none;
            margin-top: 10px;
        }

        .import-area.show {
            display: block;
        }

        .import-area textarea {
            width: 100%;
            min-height: 200px;
            margin: 10px 0;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>AI-Assisted Novel Editor</h1>

    <!-- Novel List View -->
    <div id="novelListView">
        <h2>Novels</h2>
        <ul id="novelList">
            <!-- Novel list items will be injected here -->
        </ul>
        <div>
            <input type="text" id="newNovelTitle" placeholder="New Novel Title">
            <button onclick="createNovel()">Create New Novel</button>
            <button onclick="toggleImportArea()">Import Novel</button>
        </div>
        <div class="import-area">
            <textarea id="importText" placeholder="Paste exported novel here..."></textarea>
            <button onclick="importNovel()">Import</button>
            <button onclick="toggleImportArea()">Cancel</button>
        </div>
    </div>

    <!-- Novel Editor View -->
    <div id="novelEditorView" style="display: none;">
        <button onclick="showNovelList()">← Back to Novel List</button>
        <h2 id="currentNovelTitle"></h2>
        <div class="import-export-area">
            <button onclick="exportNovel(this)">Export Novel</button>
        </div>
        <button class="delete-btn" onclick="deleteCurrentNovel()">Delete This Novel</button>
        <hr>

        <div id="chaptersContainer">
            <!-- Chapters will be injected here -->
        </div>

        <button onclick="addChapter()">+ Add New Chapter</button>
    </div>

</div>

<script>
    const LS_KEY = 'novels';
    let novels = [];
    let currentNovelId = null;

    // --- Core Data Management ---

    function loadNovels() {
        const data = localStorage.getItem(LS_KEY);
        try {
            novels = data ? JSON.parse(data) : [];
        } catch (e) {
            console.error("Error loading novels from local storage:", e);
            novels = []; // Reset if data is corrupted
        }
        // Ensure basic structure integrity
        novels.forEach(novel => {
            novel.chapters = novel.chapters || [];
            novel.chapters.forEach(chapter => {
                chapter.sceneBeats = chapter.sceneBeats || [];
                chapter.summary = chapter.summary || '';
                chapter.sceneBeats.forEach(beat => {
                    beat.generatedText = beat.generatedText || '';
                });
            });
        });
    }

    function saveNovels() {
        try {
            localStorage.setItem(LS_KEY, JSON.stringify(novels));
        } catch (e) {
            console.error("Error saving novels to local storage:", e);
            alert("Error saving data. Local storage might be full or unavailable.");
        }
    }

    function getNovelById(id) {
        return novels.find(novel => novel.id === id);
    }

    function getChapterById(novel, chapterId) {
        return novel.chapters.find(chap => chap.id === chapterId);
    }

    function getSceneBeatById(chapter, beatId) {
        return chapter.sceneBeats.find(beat => beat.id === beatId);
    }

    function generateId() {
        return Date.now().toString();
    }

    // --- UI Rendering ---

    function renderNovelList() {
        const novelListEl = document.getElementById('novelList');
        novelListEl.innerHTML = ''; // Clear current list

        if (novels.length === 0) {
            novelListEl.innerHTML = '<li>No novels found. Create one below.</li>';
            return;
        }

        novels.forEach(novel => {
            const li = document.createElement('li');
            li.innerHTML = `
                <span class="novel-item-title" onclick="openNovel('${novel.id}')">${novel.title || 'Untitled Novel'}</span>
                <div>
                    <button onclick="openNovel('${novel.id}')">Open</button>
                    <button class="delete-btn" onclick="deleteNovel('${novel.id}')">Delete</button>
                </div>
            `;
            novelListEl.appendChild(li);
        });
    }

    function renderNovelEditor() {
        const novel = getNovelById(currentNovelId);
        if (!novel) {
            console.error("Cannot render editor: Novel not found");
            showNovelList(); // Go back if novel doesn't exist
            return;
        }

        document.getElementById('currentNovelTitle').textContent = novel.title || 'Untitled Novel';
        const chaptersContainer = document.getElementById('chaptersContainer');
        chaptersContainer.innerHTML = ''; // Clear existing chapters

        novel.chapters.forEach((chapter, index) => {
            const chapterEl = document.createElement('div');
            chapterEl.classList.add('chapter');
            chapterEl.dataset.chapterId = chapter.id;
            chapterEl.dataset.chapterIndex = index;

            chapterEl.innerHTML = `
                <div class="chapter-header">
                    <input
                        type="text"
                        class="chapter-title"
                        value="${chapter.title || 'Untitled Chapter'}"
                        onchange="updateChapterTitle('${novel.id}', '${chapter.id}', this.value)"
                        placeholder="Chapter Title"
                    />
                    <div class="chapter-controls">
                        <button class="move-btn" onclick="moveChapter('${novel.id}', ${index}, -1)" ${index === 0 ? 'disabled' : ''}>↑</button>
                        <button class="move-btn" onclick="moveChapter('${novel.id}', ${index}, 1)" ${index === novel.chapters.length - 1 ? 'disabled' : ''}>↓</button>
                        <button class="delete-btn" onclick="deleteChapter('${novel.id}', '${chapter.id}')">Delete Chapter</button>
                    </div>
                </div>

                <div class="scene-beats-container">
                    <!-- Scene beats will be injected here -->
                </div>

                <div class="add-beat-area">
                    <textarea class="new-beat-text" placeholder="Add new scene beat..."></textarea>
                    <button onclick="addSceneBeat('${novel.id}', '${chapter.id}')">+ Add Beat</button>
                </div>

                <hr style="margin: 15px 0;">

                <div>
                    <h4>Chapter Summary</h4>
                    <button onclick="copyChapterSummaryPrompt('${novel.id}', '${chapter.id}', this)">Copy Summary Prompt</button>
                    <span class="feedback">Copied!</span>
                    <textarea
                        class="summary-text-area"
                        placeholder="Paste chapter summary generated by AI here..."
                        onchange="updateChapterSummary('${novel.id}', '${chapter.id}', this.value)"
                    >${chapter.summary || ''}</textarea>
                </div>
            `;
            chaptersContainer.appendChild(chapterEl);
            renderSceneBeats(novel.id, chapter.id, chapterEl.querySelector('.scene-beats-container'));
        });
    }

    function renderSceneBeats(novelId, chapterId, container) {
        const novel = getNovelById(novelId);
        const chapter = getChapterById(novel, chapterId);
        container.innerHTML = ''; // Clear existing beats

        if (!chapter || chapter.sceneBeats.length === 0) {
            container.innerHTML = '<p style="color: #888; font-style: italic;">No scene beats yet.</p>';
            return;
        }

        chapter.sceneBeats.forEach((beat, index) => {
            const beatEl = document.createElement('div');
            beatEl.classList.add('scene-beat');
            beatEl.dataset.beatId = beat.id;
            beatEl.dataset.beatIndex = index;

            beatEl.innerHTML = `
                <textarea
                    class="beat-text-area"
                    placeholder="Scene beat description..."
                    onchange="updateSceneBeatText('${novelId}', '${chapterId}', '${beat.id}', this.value)"
                >${beat.text || ''}</textarea>

                <div class="beat-controls">
                    <button class="move-btn" onclick="moveSceneBeat('${novelId}', '${chapterId}', ${index}, -1)" ${index === 0 ? 'disabled' : ''}>↑</button>
                    <button class="move-btn" onclick="moveSceneBeat('${novelId}', '${chapterId}', ${index}, 1)" ${index === chapter.sceneBeats.length - 1 ? 'disabled' : ''}>↓</button>
                    <button onclick="copyContinuePrompt('${novelId}', '${chapterId}', '${beat.id}', this)">Copy Continue Prompt</button>
                    <span class="feedback">Copied!</span>
                    <button class="delete-btn" onclick="deleteSceneBeat('${novelId}', '${chapterId}', '${beat.id}')">Delete Beat</button>
                </div>
                 <textarea
                    class="generated-text-area"
                    placeholder="Paste AI generated content here..."
                    onchange="updateGeneratedText('${novelId}', '${chapterId}', '${beat.id}', this.value)"
                >${beat.generatedText || ''}</textarea>
            `;
            container.appendChild(beatEl);
        });
    }

    // --- UI Navigation ---

    function showNovelList() {
        currentNovelId = null;
        document.getElementById('novelListView').style.display = 'block';
        document.getElementById('novelEditorView').style.display = 'none';
        document.getElementById('newNovelTitle').value = ''; // Clear input field
        renderNovelList();
    }

    function showNovelEditor() {
        document.getElementById('novelListView').style.display = 'none';
        document.getElementById('novelEditorView').style.display = 'block';
        renderNovelEditor();
    }

    // --- Novel Actions ---

    function createNovel() {
        const titleInput = document.getElementById('newNovelTitle');
        const title = titleInput.value.trim() || 'Untitled Novel';
        const newNovel = {
            id: generateId(),
            title: title,
            chapters: []
        };
        novels.push(newNovel);
        saveNovels();
        titleInput.value = ''; // Clear input
        openNovel(newNovel.id); // Automatically open the new novel
    }

    function openNovel(id) {
        currentNovelId = id;
        showNovelEditor();
    }

    function deleteNovel(id) {
        if (confirm(`Are you sure you want to delete the novel "${getNovelById(id)?.title || 'this novel'}"? This cannot be undone.`)) {
            novels = novels.filter(novel => novel.id !== id);
            saveNovels();
            renderNovelList(); // Refresh list view
        }
    }
     function deleteCurrentNovel() {
        if (currentNovelId) {
            if (confirm(`Are you sure you want to delete the novel "${getNovelById(currentNovelId)?.title || 'this novel'}"? This cannot be undone.`)) {
                novels = novels.filter(novel => novel.id !== currentNovelId);
                saveNovels();
                showNovelList(); // Go back to list view
            }
        }
    }


    // --- Chapter Actions ---

    function addChapter() {
        const novel = getNovelById(currentNovelId);
        if (!novel) return;

        const newChapter = {
            id: generateId(),
            title: `Chapter ${novel.chapters.length + 1}`,
            sceneBeats: [],
            summary: ''
        };
        novel.chapters.push(newChapter);
        saveNovels();
        renderNovelEditor(); // Re-render to show the new chapter
    }

    function deleteChapter(novelId, chapterId) {
        const novel = getNovelById(novelId);
        if (!novel) return;
        const chapter = getChapterById(novel, chapterId);

        if (confirm(`Are you sure you want to delete "${chapter?.title || 'this chapter'}" and all its scene beats?`)) {
            novel.chapters = novel.chapters.filter(chap => chap.id !== chapterId);
            saveNovels();
            renderNovelEditor(); // Re-render the editor view
        }
    }

    function updateChapterTitle(novelId, chapterId, newTitle) {
        const novel = getNovelById(novelId);
        const chapter = getChapterById(novel, chapterId);
        if (chapter) {
            chapter.title = newTitle.trim() || 'Untitled Chapter';
            saveNovels();
            // No need to re-render fully, but might update other parts if title is used elsewhere later
            // For safety/simplicity, a targeted update or full re-render is fine here.
            // Let's just update the main novel title display in case it was 'Untitled Novel' before
             document.getElementById('currentNovelTitle').textContent = novel.title || 'Untitled Novel';
        }
    }

    function updateChapterSummary(novelId, chapterId, summaryText) {
        const novel = getNovelById(novelId);
        const chapter = getChapterById(novel, chapterId);
        if (chapter) {
            chapter.summary = summaryText;
            saveNovels();
        }
    }

    function moveChapter(novelId, chapterIndex, direction) { // direction: -1 for up, 1 for down
        const novel = getNovelById(novelId);
        if (!novel) return;

        const newIndex = chapterIndex + direction;
        if (newIndex < 0 || newIndex >= novel.chapters.length) {
            return; // Invalid move
        }

        // Swap elements
        const temp = novel.chapters[chapterIndex];
        novel.chapters[chapterIndex] = novel.chapters[newIndex];
        novel.chapters[newIndex] = temp;

        saveNovels();
        renderNovelEditor(); // Re-render to reflect new order
    }


    // --- Scene Beat Actions ---

    function addSceneBeat(novelId, chapterId) {
        const novel = getNovelById(novelId);
        const chapter = getChapterById(novel, chapterId);
        if (!chapter) return;

        // Find the specific chapter element to get the text from the correct input
        const chapterElement = document.querySelector(`.chapter[data-chapter-id="${chapterId}"]`);
        const newBeatTextArea = chapterElement.querySelector('.new-beat-text');
        const text = newBeatTextArea.value.trim();

        if (!text) {
            alert("Please enter some text for the scene beat.");
            return;
        }

        const newBeat = {
            id: generateId(),
            text: text,
            generatedText: ''
        };
        chapter.sceneBeats.push(newBeat);
        saveNovels();
        newBeatTextArea.value = ''; // Clear the input field

        // Re-render just the scene beats for this chapter for efficiency
        const beatsContainer = chapterElement.querySelector('.scene-beats-container');
        renderSceneBeats(novelId, chapterId, beatsContainer);
         // After adding, focus the next element or a relevant control if desired
        newBeatTextArea.focus();
    }

    function deleteSceneBeat(novelId, chapterId, beatId) {
        const novel = getNovelById(novelId);
        const chapter = getChapterById(novel, chapterId);
        if (!chapter) return;

        if (confirm('Are you sure you want to delete this scene beat?')) {
            chapter.sceneBeats = chapter.sceneBeats.filter(beat => beat.id !== beatId);
            saveNovels();
            // Re-render just the scene beats for this chapter
            const chapterElement = document.querySelector(`.chapter[data-chapter-id="${chapterId}"]`);
            const beatsContainer = chapterElement.querySelector('.scene-beats-container');
            renderSceneBeats(novelId, chapterId, beatsContainer);
        }
    }

    function updateSceneBeatText(novelId, chapterId, beatId, newText) {
        const novel = getNovelById(novelId);
        const chapter = getChapterById(novel, chapterId);
        const beat = getSceneBeatById(chapter, beatId);
        if (beat) {
            beat.text = newText; // Keep whitespace as entered
            saveNovels();
        }
    }

    function updateGeneratedText(novelId, chapterId, beatId, genText) {
         const novel = getNovelById(novelId);
        const chapter = getChapterById(novel, chapterId);
        const beat = getSceneBeatById(chapter, beatId);
        if (beat) {
            beat.generatedText = genText;
            saveNovels();
        }
    }

    function moveSceneBeat(novelId, chapterId, beatIndex, direction) { // -1 up, 1 down
        const novel = getNovelById(novelId);
        const chapter = getChapterById(novel, chapterId);
        if (!chapter) return;

        const newIndex = beatIndex + direction;
        if (newIndex < 0 || newIndex >= chapter.sceneBeats.length) {
            return; // Invalid move
        }

        // Swap elements
        const temp = chapter.sceneBeats[beatIndex];
        chapter.sceneBeats[beatIndex] = chapter.sceneBeats[newIndex];
        chapter.sceneBeats[newIndex] = temp;

        saveNovels();
        // Re-render just the scene beats for this chapter
        const chapterElement = document.querySelector(`.chapter[data-chapter-id="${chapterId}"]`);
        const beatsContainer = chapterElement.querySelector('.scene-beats-container');
        renderSceneBeats(novelId, chapterId, beatsContainer);
    }

    // --- Prompt Generation & Clipboard ---

    function copyToClipboard(text, buttonElement) {
        navigator.clipboard.writeText(text).then(() => {
            // Show feedback next to the button
            const feedbackEl = buttonElement.nextElementSibling;
            if (feedbackEl && feedbackEl.classList.contains('feedback')) {
                feedbackEl.classList.add('show');
                setTimeout(() => {
                    feedbackEl.classList.remove('show');
                }, 1500); // Hide after 1.5 seconds
            }
            console.log('Prompt copied to clipboard');
        }).catch(err => {
            console.error('Failed to copy prompt: ', err);
            alert('Failed to copy prompt. Your browser might not support this feature or permission was denied.');
        });
    }

    function copyChapterSummaryPrompt(novelId, chapterId, buttonElement) {
        const novel = getNovelById(novelId);
        const chapter = getChapterById(novel, chapterId);
        if (!chapter) return;

        const chapterText = chapter.sceneBeats.map(beat => beat.text).join('\n\n'); // Join beats with double newline

        const prompt = `Make summary of this chapter.\n\n${chapterText}`;

        copyToClipboard(prompt, buttonElement);
    }

    function copyContinuePrompt(novelId, chapterId, beatId, buttonElement) {
        const novel = getNovelById(novelId);
        const chapter = getChapterById(novel, chapterId);
        const beat = getSceneBeatById(chapter, beatId);
        if (!novel || !chapter || !beat) return;

        const chapterIndex = novel.chapters.findIndex(ch => ch.id === chapterId);
        const beatIndex = chapter.sceneBeats.findIndex(b => b.id === beatId);

        // Build story so far section
        let storySoFar = '';
        
        // Add previous chapters' summaries
        for (let i = 0; i < chapterIndex; i++) {
            if (novel.chapters[i].summary) {
                storySoFar += `Chapter ${i + 1}: ${novel.chapters[i].title || 'Untitled'}\n${novel.chapters[i].summary}\n\n`;
            }
        }
        
        // Add current chapter's previous beats
        for (let i = 0; i < beatIndex; i++) {
            storySoFar += chapter.sceneBeats[i].text + "\n\n";
        }

        // Construct the prompt using the template
        let prompt = 'The story so far:\n<storySoFar>\n';
        prompt += storySoFar;
        prompt += '</storySoFar>\n\n';
        prompt += 'You are an expert fiction writer. Continue the story and write about 400 words for the following instructions:\n';
        prompt += '<instructions>\n';
        prompt += beat.text;
        prompt += '\n</instructions>\n\n';
        prompt += 'NEVER conclude the scene on your own, follow the beat instructions very closely. NEVER end with foreshadowing. NEVER write further than what I prompt you with. AVOID imagining possible endings, NEVER deviate from the instructions.\n\n';
        prompt += 'STOP EARLY if the continuation contains what was required in the instructions. You do not need to fill out the full amount of words possible.\n\n';
        prompt += '- Do not use bold or italic font.\n';
        prompt += '- Do not use expressions like "mechanical precision," "with rapid efficiency," or "at a steady pace", "her stride controlled, efficient", "this is not ideal".\n';
        prompt += '- CT32F, from whose perspective the story is told, cannot feel or detect emotions in others. She cannot feel pain. She cannot assess things like beauty, nor does she feel the wind or cold.\n';
        prompt += '- Do not measure parameters of the environment or mention these numbers.\n';
        prompt += '- Write in active voice. Use British, American, Scientific, International, and Commercial English (Basic English) for everything except dialogues. For dialogues, use the language that ordinary people in the 1980x would use.\n';
        prompt += '- Use sarcasm and dry humor. Make sarcastic jokes in the internal monologue.';

        copyToClipboard(prompt.trim(), buttonElement);
    }

    function exportNovel(buttonElement) {
        const novel = getNovelById(currentNovelId);
        if (!novel) return;

        let markdown = `# ${novel.title}\n\n`;

        novel.chapters.forEach((chapter, chapterIndex) => {
            markdown += `## ${chapter.title}\n\n`;
            
            if (chapter.summary) {
                markdown += `### Summary\n\n${chapter.summary}\n\n`;
            }

            markdown += `### Scene Beats\n\n`;
            chapter.sceneBeats.forEach((beat, beatIndex) => {
                markdown += `#### Beat ${beatIndex + 1}\n\n`;
                markdown += `**Scene Description:**\n${beat.text}\n\n`;
                if (beat.generatedText) {
                    markdown += `**Generated Content:**\n${beat.generatedText}\n\n`;
                }
            });
        });

        copyToClipboard(markdown, buttonElement);
    }

    function toggleImportArea() {
        const importArea = document.querySelector('.import-area');
        importArea.classList.toggle('show');
        if (!importArea.classList.contains('show')) {
            document.getElementById('importText').value = '';
        }
    }

    function importNovel() {
        const text = document.getElementById('importText').value.trim();
        if (!text) {
            alert('Please paste the novel content first.');
            return;
        }

        try {
            const novel = {
                id: generateId(),
                title: 'Imported Novel',
                chapters: []
            };

            const lines = text.split('\n');
            let currentChapter = null;
            let currentBeat = null;
            let currentSection = null;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                if (line.startsWith('# ')) {
                    novel.title = line.substring(2);
                } else if (line.startsWith('## ')) {
                    currentChapter = {
                        id: generateId(),
                        title: line.substring(3),
                        summary: '',
                        sceneBeats: []
                    };
                    novel.chapters.push(currentChapter);
                } else if (line === '### Summary') {
                    currentSection = 'summary';
                    i++; // Skip empty line
                } else if (line === '### Scene Beats') {
                    currentSection = 'beats';
                } else if (line.startsWith('#### Beat')) {
                    currentBeat = {
                        id: generateId(),
                        text: '',
                        generatedText: ''
                    };
                    currentChapter.sceneBeats.push(currentBeat);
                } else if (line.startsWith('**Scene Description:**')) {
                    i++;
                    let description = [];
                    while (i < lines.length && lines[i].trim() !== '**Generated Content:**' && !lines[i].trim().startsWith('####')) {
                        description.push(lines[i]);
                        i++;
                    }
                    i--;
                    currentBeat.text = description.join('\n').trim();
                } else if (line.startsWith('**Generated Content:**')) {
                    i++;
                    let generated = [];
                    while (i < lines.length && !lines[i].trim().startsWith('####')) {
                        generated.push(lines[i]);
                        i++;
                    }
                    i--;
                    currentBeat.generatedText = generated.join('\n').trim();
                } else if (currentSection === 'summary' && line) {
                    currentChapter.summary = line;
                }
            }

            novels.push(novel);
            saveNovels();
            toggleImportArea();
            showNovelList();
        } catch (e) {
            console.error('Import error:', e);
            alert('Error importing novel. Please check the format.');
        }
    }

    // --- Initialization ---

    document.addEventListener('DOMContentLoaded', () => {
        loadNovels();
        showNovelList(); // Start by showing the list of novels
    });

</script>

</body>
</html>
