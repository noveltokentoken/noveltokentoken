<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>React AI-Assisted Novel Editor</title>
    <style>
      /* --- Base & Variables --- */
      :root {
        --primary-color: #4f46e5; /* Indigo */
        --primary-color-hover: #4338ca;
        --danger-color: #dc2626; /* Red */
        --danger-color-hover: #b91c1c;
        --warning-color: #f59e0b; /* Amber */
        --warning-color-hover: #d97706;
        --secondary-color: #6b7280; /* Gray */
        --secondary-color-hover: #4b5563;
        --light-bg: #f9fafb; /* Very light gray */
        --medium-bg: #f3f4f6; /* Light gray */
        --container-bg: #ffffff;
        --text-color: #1f2937; /* Darker gray */
        --text-color-light: #6b7280; /* Medium gray */
        --border-color: #e5e7eb; /* Lighter gray border */
        --border-radius: 6px;
        --box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1),
          0 1px 2px -1px rgba(0, 0, 0, 0.1);
        --box-shadow-lg: 0 4px 6px -1px rgba(0, 0, 0, 0.1),
          0 2px 4px -2px rgba(0, 0, 0, 0.1);
      }

      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue",
          sans-serif;
        line-height: 1.6;
        margin: 0; /* Remove default margin */
        padding: 30px; /* Add padding around the body */
        background-color: var(--medium-bg);
        color: var(--text-color);
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      /* --- Typography --- */
      h1,
      h2,
      h3,
      h4 {
        color: var(--text-color);
        margin-top: 0;
        margin-bottom: 0.75em;
        line-height: 1.3;
      }
      h1 {
        font-size: 2em;
        font-weight: 600;
        margin-bottom: 1em;
      }
      h2 {
        font-size: 1.5em;
        font-weight: 600;
      }
      h3 {
        font-size: 1.25em;
        font-weight: 600;
      }
      h4 {
        font-size: 1.1em;
        font-weight: 600;
      }
      p {
        margin-bottom: 1em;
      }

      /* --- Layout --- */
      .container {
        max-width: 1200px;
        margin: 0 auto; /* Center container */
        background: var(--container-bg);
        padding: 30px; /* More padding */
        box-shadow: var(--box-shadow-lg);
        border-radius: var(--border-radius);
      }

      .view {
        margin-top: 25px;
      }

      hr {
        border: none;
        border-top: 1px solid var(--border-color);
        margin: 30px 0; /* More spacing */
      }

      /* --- Buttons --- */
      button {
        padding: 9px 15px;
        margin: 5px 4px;
        cursor: pointer;
        background-color: var(--primary-color);
        color: white;
        border: none;
        border-radius: var(--border-radius);
        font-size: 0.9rem;
        font-weight: 500;
        transition: background-color 0.2s ease-in-out,
          box-shadow 0.2s ease-in-out;
        box-shadow: var(--box-shadow);
      }

      button:hover {
        background-color: var(--primary-color-hover);
        box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.15);
      }

      button:focus {
        outline: 2px solid transparent;
        outline-offset: 2px;
        box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.4); /* Primary color focus ring */
      }
      button:focus:not(:focus-visible) {
        /* Remove focus ring if not keyboard focused */
        box-shadow: none;
      }

      button.delete-btn {
        background-color: var(--danger-color);
      }
      button.delete-btn:hover {
        background-color: var(--danger-color-hover);
      }
      button.delete-btn:focus {
        box-shadow: 0 0 0 3px rgba(220, 38, 38, 0.4); /* Danger color focus ring */
      }

      button.move-btn {
        background-color: var(--warning-color);
        font-weight: bold;
        padding: 5px 10px;
        min-width: 35px;
        font-size: 1rem; /* Make arrows slightly larger */
      }
      button.move-btn:hover {
        background-color: var(--warning-color-hover);
      }
      button.move-btn:focus {
        box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.4); /* Warning color focus ring */
      }

      button:disabled {
        background-color: #ccc;
        cursor: not-allowed;
        box-shadow: none;
        opacity: 0.7;
      }

      button.secondary-btn {
        background-color: var(--secondary-color);
        color: white;
      }
      button.secondary-btn:hover {
        background-color: var(--secondary-color-hover);
      }
      button.secondary-btn:focus {
        box-shadow: 0 0 0 3px rgba(107, 114, 128, 0.4); /* Secondary color focus ring */
      }

      /* --- Input Fields & Textareas --- */
      input[type="text"],
      textarea {
        padding: 10px 12px;
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        font-size: 0.95rem;
        width: 100%;
        box-sizing: border-box;
        transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
      }

      input[type="text"]:focus,
      textarea:focus {
        border-color: var(--primary-color);
        outline: 2px solid transparent;
        outline-offset: 2px;
        box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.3); /* Primary color focus glow */
      }

      textarea {
        min-height: 60px;
        line-height: 1.5;
        resize: vertical;
      }

      /* --- Novel List View --- */
      #novelList {
        list-style: none;
        padding: 0;
        margin: 20px 0;
      }

      #novelList li {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px 20px; /* More padding */
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        margin-bottom: 10px;
        background-color: var(--container-bg);
        transition: box-shadow 0.2s ease-in-out, border-color 0.2s ease-in-out;
      }
      #novelList li:hover {
        border-color: #c7d2fe; /* Lighter primary on hover */
        box-shadow: var(--box-shadow);
      }

      .novel-item-title {
        font-weight: 600; /* Bolder title */
        cursor: pointer;
        color: var(--primary-color);
        font-size: 1.1em;
        flex-grow: 1;
        margin-right: 15px;
      }
      .novel-item-title:hover {
        text-decoration: underline;
        color: var(--primary-color-hover);
      }

      #novelList li div button {
        /* Reduce margin for buttons in list */
        margin: 0 0 0 8px;
      }

      /* Create/Import Novel Area */
      .create-import-area {
        display: flex;
        align-items: center;
        gap: 10px; /* Space between items */
        margin-top: 20px;
        padding: 15px;
        background-color: var(--light-bg);
        border-radius: var(--border-radius);
      }
      .create-import-area input[type="text"] {
        flex-grow: 1; /* Take available space */
      }

      /* --- Novel Editor View --- */
      .novel-title-edit input[type="text"] {
        font-size: 1.8em; /* Larger title */
        font-weight: 600;
        margin-bottom: 15px;
        padding: 12px 15px;
        border: none; /* No border unless focused */
        border-bottom: 2px solid transparent; /* Space for focus */
        border-radius: 0;
        width: 100%;
        box-shadow: none;
      }
      .novel-title-edit input[type="text"]:focus {
        border-bottom-color: var(--primary-color);
        box-shadow: none; /* Override general focus */
        background-color: var(--light-bg);
      }

      .import-export-area {
        margin: 15px 0 25px 0;
        padding: 15px;
        background: var(--light-bg);
        border-radius: var(--border-radius);
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: center;
      }

      .import-area {
        margin-top: 15px;
        padding: 15px;
        background-color: var(--medium-bg);
        border: 1px dashed var(--border-color);
        border-radius: var(--border-radius);
      }

      .import-area textarea {
        width: 100%;
        min-height: 150px;
        margin: 10px 0;
        box-sizing: border-box;
      }

      .chapter-filter {
        margin: 15px 0 25px 0;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .chapter-filter label {
        font-weight: 500;
        color: var(--text-color-light);
      }
      .chapter-filter select {
        padding: 8px 12px;
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        background-color: white;
        min-width: 200px;
      }

      /* --- Chapter --- */
      .chapter {
        margin-bottom: 40px; /* More space between chapters */
        padding: 25px;
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        background-color: var(
          --container-bg
        ); /* White background for chapters */
        box-shadow: var(--box-shadow);
      }

      .chapter-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        flex-wrap: wrap;
        gap: 15px; /* Space between title and controls */
        padding-bottom: 15px;
        border-bottom: 1px solid var(--border-color);
      }

      .chapter-title {
        font-size: 1.3em; /* Slightly larger */
        font-weight: 600;
        border: none;
        padding: 8px 0; /* Padding only vertical */
        flex-grow: 1;
        margin-right: 10px;
        background: transparent;
        border-radius: 0;
        box-shadow: none;
        border-bottom: 2px solid transparent; /* For focus state */
        width: auto; /* Don't force full width */
      }
      .chapter-title:focus {
        outline: none;
        background-color: #f0f0ff; /* Light primary bg */
        border-bottom: 2px solid var(--primary-color);
        box-shadow: none;
      }

      .chapter-controls {
        display: flex;
        align-items: center;
        flex-shrink: 0; /* Prevent controls from shrinking too much */
        gap: 8px; /* Space between control buttons */
      }
      .chapter-controls button,
      .beat-controls button {
        margin: 0; /* Remove default button margin */
      }

      /* --- Scene Beat --- */
      .scene-beat {
        /* Remove old borders */
        border: none;
        padding: 20px;
        margin: 20px 0; /* Space between beats */
        background-color: var(
          --light-bg
        ); /* Light background to group beat content */
        border-radius: var(--border-radius);
        position: relative; /* For potential future decorations */
      }

      /* Style the instruction label */
      .scene-beat > p:first-of-type {
        margin-bottom: 8px;
        font-size: 0.9em;
        color: var(--text-color-light);
        font-weight: 500;
      }

      /* Instruction Text Area (Display) */
      .beat-text-area {
        padding: 12px;
        background-color: #e0e7ff; /* Slightly different light blue for instructions */
        border: 1px solid #c7d2fe;
        border-radius: var(--border-radius);
        min-height: 60px;
        white-space: pre-wrap;
        width: 100%;
        box-sizing: border-box;
        color: var(--text-color);
        line-height: 1.5;
        margin-bottom: 15px; /* Space before controls */
      }

      .beat-controls {
        display: flex;
        justify-content: flex-end;
        align-items: center;
        margin-top: 10px;
        margin-bottom: 20px; /* Space before generated text */
        flex-wrap: wrap;
        gap: 8px; /* Space between beat control buttons */
      }

      /* Style the generated content label */
      .scene-beat > p:nth-of-type(2) {
        /* Assuming label is 2nd p */
        margin-top: 20px; /* Space above label */
        margin-bottom: 8px;
        font-size: 0.9em;
        color: var(--text-color-light);
        font-weight: 500;
      }

      /* Generated Text Display */
      .generated-text-area-display {
        padding: 15px;
        background-color: #ffffff; /* White background like main container */
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        min-height: 80px;
        white-space: pre-wrap;
        color: var(--text-color);
        line-height: 1.6;
        font-size: 1rem; /* Slightly larger for readability */
        margin-bottom: 10px; /* Space before edit button */
      }

      /* Generated text edit button alignment */
      .generated-text-edit-controls {
        text-align: right;
        margin-top: 5px;
      }

      /* --- Add Beat Area --- */
      .add-beat-area {
        margin-top: 25px;
        padding: 20px;
        background-color: var(--medium-bg);
        border-radius: var(--border-radius);
        display: flex;
        align-items: flex-start; /* Align top */
        gap: 10px;
      }

      .add-beat-area textarea {
        flex-grow: 1;
        margin-right: 10px;
        min-height: 50px; /* Slightly taller */
      }
      .add-beat-area button {
        flex-shrink: 0; /* Prevent button from shrinking */
      }

      /* --- Chapter Summary --- */
      .summary-section {
        transition: max-height 0.3s ease-out, opacity 0.3s ease-out,
          margin-top 0.3s ease-out;
        overflow: hidden;
        max-height: 1000px; /* Large enough for content */
        opacity: 1;
        margin-top: 15px;
      }

      .summary-section.collapsed {
        max-height: 0;
        opacity: 0;
        margin-top: 0;
        /* Hide elements inside instantly to prevent interaction */
        pointer-events: none;
      }
      .summary-section.collapsed > * {
        visibility: hidden;
      }

      .summary-header {
        display: flex;
        align-items: center;
        cursor: pointer;
        gap: 8px;
        padding: 10px 0;
        border-top: 1px solid var(--border-color);
        margin-top: 30px; /* Separate from beats */
        user-select: none; /* Prevent text selection on click */
      }
      .summary-header:hover h4 {
        color: var(--primary-color);
      }

      .summary-header h4 {
        margin: 0;
        color: var(--text-color-light);
        transition: color 0.2s ease-in-out;
        font-weight: 600;
      }

      .collapse-indicator {
        font-size: 16px;
        line-height: 1;
        transition: transform 0.3s;
        display: inline-block;
        color: var(--text-color-light);
      }
      .summary-header:not(.collapsed) .collapse-indicator {
        transform: rotate(0deg);
      }
      .summary-header.collapsed .collapse-indicator {
        transform: rotate(-90deg);
      }

      .summary-controls {
        /* Container for summary button + feedback */
        margin-bottom: 10px;
      }
      .summary-text-area {
        min-height: 120px; /* Taller summary area */
        background-color: var(--container-bg);
      }

      /* --- Feedback --- */
      .feedback-container {
        display: inline-block;
        min-width: 70px; /* Prevent layout shift */
        text-align: left;
        margin-left: 10px;
        vertical-align: middle;
      }
      .feedback {
        color: #16a34a; /* Green */
        font-size: 0.9em;
        font-weight: 500;
        opacity: 0;
        transition: opacity 0.3s ease-out;
      }
      .feedback.show {
        opacity: 1;
      }

      /* --- Modal Dialog Styles --- */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.6); /* Darker overlay */
        z-index: 1000;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 20px; /* Padding for smaller screens */
        box-sizing: border-box;
        opacity: 0; /* Start hidden for animation */
        animation: fadeIn 0.2s ease-out forwards;
      }
      @keyframes fadeIn {
        to {
          opacity: 1;
        }
      }

      .modal-dialog {
        background-color: var(--container-bg);
        max-width: 90%;
        width: 800px;
        max-height: 85vh; /* Allow slightly more height */
        border-radius: var(--border-radius);
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1),
          0 4px 6px -4px rgba(0, 0, 0, 0.1);
        display: flex;
        flex-direction: column;
        transform: scale(0.95); /* Start slightly small for animation */
        opacity: 0;
        animation: zoomIn 0.2s 0.1s ease-out forwards;
      }
      @keyframes zoomIn {
        to {
          transform: scale(1);
          opacity: 1;
        }
      }

      .modal-header {
        padding: 15px 20px;
        border-bottom: 1px solid var(--border-color);
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-shrink: 0;
      }

      .modal-title {
        font-size: 1.2em;
        font-weight: 600;
        margin: 0;
      }

      .modal-close {
        background: none;
        border: none;
        font-size: 1.8em; /* Larger close button */
        cursor: pointer;
        color: var(--text-color-light);
        padding: 0 5px; /* Easier to click */
        margin: -5px -5px -5px 0; /* Adjust position slightly */
        line-height: 1;
        transition: color 0.2s ease-in-out;
      }
      .modal-close:hover {
        color: var(--text-color);
      }

      .modal-body {
        padding: 20px;
        overflow-y: auto;
        flex-grow: 1;
      }

      .modal-footer {
        padding: 15px 20px;
        border-top: 1px solid var(--border-color);
        display: flex;
        justify-content: flex-end;
        background-color: var(--light-bg); /* Subtle footer background */
        border-bottom-left-radius: var(--border-radius);
        border-bottom-right-radius: var(--border-radius);
        flex-shrink: 0;
        gap: 10px; /* Space between footer buttons */
      }

      .modal-footer button {
        margin: 0; /* Remove default margin */
      }

      .prompt-textarea {
        width: 100%;
        min-height: 350px; /* Taller text area */
        font-family: "Menlo", "Monaco", "Consolas", monospace; /* Monospace for prompts */
        font-size: 0.9rem;
        padding: 15px;
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        margin-bottom: 10px;
        resize: vertical;
        box-sizing: border-box;
        background-color: var(--light-bg); /* Light bg for readonly textareas */
      }
      .prompt-textarea:not([readOnly]) {
        background-color: var(--container-bg); /* White if editable */
      }

      /* --- Settings Styles (Template Help) --- */
      .template-help {
        font-size: 0.9em;
        color: var(--text-color-light);
        margin-top: 15px;
        padding: 10px;
        background-color: var(--medium-bg);
        border-radius: var(--border-radius);
      }
      .template-help p {
        margin-bottom: 5px;
      }
      .template-help ul {
        margin: 5px 0 0 20px;
        padding: 0;
      }
      .template-help code {
        background-color: #e5e7eb;
        padding: 2px 5px;
        border-radius: 4px;
        font-family: "Menlo", "Monaco", "Consolas", monospace;
        color: var(--primary-color);
      }

      /* Novel Text Modal Specifics */
      .novel-text-display {
        white-space: pre-wrap;
        font-family: "Georgia", "Times New Roman", Times, serif; /* Serif for novel text */
        line-height: 1.7;
        padding: 20px;
        background-color: #fff;
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        font-size: 1rem;
        color: #333; /* Slightly lighter black for reading */
      }
      .novel-text-modal-body {
        /* Add wrapper for max height */
        max-height: 65vh;
        overflow-y: auto;
        padding: 5px; /* Padding around the scrollable area */
      }
    </style>
  </head>
  <body>
    <!-- Root element for React -->
    <div id="root"></div>

    <!-- React and Babel CDNs -->
    <script
      src="https://unpkg.com/react@18/umd/react.development.js"
      crossorigin
    ></script>
    <script
      src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"
      crossorigin
    ></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

    <!-- React Application Code (using Babel) -->
    <script type="text/babel">
      const { useState, useEffect, useCallback, useMemo } = React;

      // --- Constants ---
      const LS_KEY = "novels_react";
      const LS_SUMMARY_STATE_KEY = "chapterSummaryStates_react";
      const DEFAULT_PROMPT_TEMPLATE = `The story so far:
{storySoFar}

You are an expert fiction writer. Continue the story and write about 400 words for the following instructions:
{instructions}

NEVER conclude the scene on your own, follow the beat instructions very closely. NEVER end with foreshadowing. NEVER write further than what I prompt you with. AVOID imagining possible endings, NEVER deviate from the instructions.

STOP EARLY if the continuation contains what was required in the instructions. You do not need to fill out the full amount of words possible.

- Do not use bold or italic font.
- Do not use expressions like "mechanical precision," "with rapid efficiency," or "at a steady pace", "her stride controlled, efficient", "this is not ideal".
- CT32F, from whose perspective the story is told, cannot feel or detect emotions in others. She cannot feel pain. She cannot assess things like beauty, nor does she feel the wind or cold.
- Do not measure parameters of the environment or mention these numbers.
- Write in active voice. Use British, American, Scientific, International, and Commercial English (Basic English) for everything except dialogues. For dialogues, use the language that ordinary people in the 1980x would use.
- Use sarcasm and dry humor. Make sarcastic jokes in the internal monologue.`;

      // --- Helper Functions ---
      function generateId() {
        return (
          Date.now().toString(36) + Math.random().toString(36).substring(2)
        );
      }

      function getEffectiveTemplate(novel) {
        return (novel && novel.template) || DEFAULT_PROMPT_TEMPLATE;
      }

      function copyToClipboard(text) {
        if (!text) return Promise.reject(new Error("Nothing to copy"));
        return navigator.clipboard.writeText(text);
      }

      function findChapeter(novel, chapterId) {
        if (!novel || !novel.chapters) return null;
        return novel.chapters.find((chapter) => chapter.id === chapterId);
      }

      // --- Modal Component ---
      function Modal({ title, children, footer, onClose }) {
        // Handle Escape key press
        useEffect(() => {
          const handleKeyDown = (event) => {
            if (event.key === "Escape") {
              onClose();
            }
          };
          document.addEventListener("keydown", handleKeyDown);
          return () => {
            document.removeEventListener("keydown", handleKeyDown);
          };
        }, [onClose]); // Re-add listener if onClose changes

        return (
          <div className="modal-overlay" onClick={onClose}>
            {" "}
            {/* Close on overlay click */}
            <div className="modal-dialog" onClick={(e) => e.stopPropagation()}>
              {" "}
              {/* Prevent closing when clicking inside dialog */}
              <div className="modal-header">
                <h3 className="modal-title">{title}</h3>
                <button className="modal-close" onClick={onClose}>
                  ×
                </button>
              </div>
              <div className="modal-body">{children}</div>
              <div className="modal-footer">{footer}</div>
            </div>
          </div>
        );
      }

      // --- Feedback Component ---
      function FeedbackMessage({ show, message = "Copied!" }) {
        return (
          <span className={`feedback ${show ? "show" : ""}`}>{message}</span>
        );
      }

      // --- SceneBeat Component ---
      function SceneBeat({
        novelId,
        chapterId,
        beat,
        beatIndex,
        totalBeats,
        // onUpdateBeatText, // Replaced by onEditBeat trigger
        onUpdateGeneratedText, // Still needed for clear
        onDeleteBeat,
        onMoveBeat,
        onShowPrompt,
        onEditBeat,
        onShowEditGeneratedTextModal, // **** NEW PROP ****
      }) {
        return (
          <div className="scene-beat">
            <p
              style={{ marginBottom: "2px", fontSize: "0.9em", color: "#555" }}
            >
              <strong>Scene Beat Instruction:</strong>
            </p>
            {/* Display beat text as static paragraph */}
            <p
              className="beat-text-area"
              style={{
                padding: "8px",
                backgroundColor: "#f5f5f5",
                borderRadius: "4px",
                minHeight: "60px",
                whiteSpace: "pre-wrap",
                width: "100%" /* Make full width */,
                boxSizing:
                  "border-box" /* Include padding in width calculation */,
              }}
            >
              {beat.text || ""}
            </p>

            <div className="beat-controls">
              <button
                className="move-btn"
                onClick={() => onMoveBeat(novelId, chapterId, beat.id, -1)}
                disabled={beatIndex === 0}
              >
                ↑
              </button>
              <button
                className="move-btn"
                onClick={() => onMoveBeat(novelId, chapterId, beat.id, 1)}
                disabled={beatIndex === totalBeats - 1}
              >
                ↓
              </button>
              <button onClick={() => onEditBeat(novelId, chapterId, beat.id)}>
                Edit Instruction
              </button>
              <button onClick={() => onShowPrompt(novelId, chapterId, beat.id)}>
                Show Prompt
              </button>
              <button
                className="delete-btn"
                onClick={() => onDeleteBeat(novelId, chapterId, beat.id)}
              >
                Delete Beat
              </button>
            </div>

            <p
              style={{
                marginTop: "10px",
                marginBottom: "2px",
                fontSize: "0.9em",
                color: "#555",
              }}
            >
              <strong>AI Generated Content:</strong>
            </p>
            {/* Display generated text */}
            <div
              className="generated-text-area-display" // Use display class
            >
              {beat.generatedText}
            </div>
            <div style={{ textAlign: "right", marginTop: "5px" }}>
              <button
                onClick={() =>
                  onShowEditGeneratedTextModal(
                    novelId,
                    chapterId,
                    beat.id,
                    beat.generatedText
                  )
                }
                style={{ marginLeft: "5px" }}
              >
                Edit Content
              </button>
            </div>
          </div>
        );
      }

      // --- ChapterSummary Component ---
      function ChapterSummary({
        novelId,
        chapter,
        isCollapsed,
        onToggleCollapse,
        onUpdateSummary,
        onCopySummaryPrompt,
      }) {
        const [copyFeedback, setCopyFeedback] = useState(false);

        const handleCopyPrompt = () => {
          onCopySummaryPrompt(novelId, chapter.id)
            .then(() => {
              setCopyFeedback(true);
              setTimeout(() => setCopyFeedback(false), 1500);
            })
            .catch((err) => {
              console.error("Failed to copy summary prompt:", err);
              alert("Failed to copy. See console for details.");
            });
        };

        return (
          <div>
            <div
              className={`summary-header ${isCollapsed ? "collapsed" : ""}`}
              onClick={() => onToggleCollapse(chapter.id)}
            >
              <span className="collapse-indicator">▼</span>
              <h4>Chapter Summary</h4>
            </div>
            <div
              className={`summary-section ${isCollapsed ? "collapsed" : ""}`}
            >
              <button onClick={handleCopyPrompt}>Copy Summary Prompt</button>
              <div className="feedback-container">
                <FeedbackMessage show={copyFeedback} />
              </div>
              <textarea
                className="summary-text-area"
                placeholder="Paste chapter summary generated by AI here..."
                value={chapter.summary || ""}
                onChange={(e) =>
                  onUpdateSummary(novelId, chapter.id, e.target.value)
                }
              />
            </div>
          </div>
        );
      }

      // --- Chapter Component ---
      function Chapter({
        novelId,
        chapter,
        chapterIndex,
        totalChapters,
        onUpdateChapterTitle,
        onDeleteChapter,
        onMoveChapter,
        onAddBeat,
        // onUpdateBeatText, // Removed - handled by modal now
        onUpdateGeneratedText,
        onDeleteBeat,
        onMoveBeat,
        onShowPrompt,
        isSummaryCollapsed,
        onToggleSummaryCollapse,
        onUpdateChapterSummary,
        onCopySummaryPrompt,
        onEditBeat,
        onShowEditGeneratedTextModal, // **** NEW PROP ****
      }) {
        const [newBeatText, setNewBeatText] = useState("");

        const handleAddBeat = () => {
          if (!newBeatText.trim()) {
            alert("Please enter some text for the scene beat instruction.");
            return;
          }
          onAddBeat(novelId, chapter.id, newBeatText);
          setNewBeatText(""); // Clear input after adding
        };

        return (
          <div className="chapter">
            <div className="chapter-header">
              <input
                type="text"
                className="chapter-title"
                value={chapter.title || ""}
                onChange={(e) =>
                  onUpdateChapterTitle(novelId, chapter.id, e.target.value)
                }
                placeholder="Chapter Title"
              />
              <div className="chapter-controls">
                <button
                  className="move-btn"
                  onClick={() => onMoveChapter(novelId, chapter.id, -1)}
                  disabled={chapterIndex === 0}
                >
                  ↑
                </button>
                <button
                  className="move-btn"
                  onClick={() => onMoveChapter(novelId, chapter.id, 1)}
                  disabled={chapterIndex === totalChapters - 1}
                >
                  ↓
                </button>
                <button
                  className="delete-btn"
                  onClick={() => onDeleteChapter(novelId, chapter.id)}
                >
                  Delete Chapter
                </button>
              </div>
            </div>

            <div className="scene-beats-container">
              {chapter.sceneBeats.length === 0 ? (
                <p style={{ color: "#888", fontStyle: "italic" }}>
                  No scene beats yet.
                </p>
              ) : (
                chapter.sceneBeats.map((beat, index) => (
                  <SceneBeat
                    key={beat.id}
                    novelId={novelId}
                    chapterId={chapter.id}
                    beat={beat}
                    beatIndex={index}
                    totalBeats={chapter.sceneBeats.length}
                    // onUpdateBeatText removed
                    onUpdateGeneratedText={onUpdateGeneratedText}
                    onDeleteBeat={onDeleteBeat}
                    onMoveBeat={onMoveBeat}
                    onShowPrompt={onShowPrompt}
                    onEditBeat={onEditBeat}
                    onShowEditGeneratedTextModal={onShowEditGeneratedTextModal} // **** PASS DOWN ****
                  />
                ))
              )}
            </div>

            <div className="add-beat-area">
              <textarea
                className="new-beat-text"
                placeholder="Add new scene beat instruction..."
                value={newBeatText}
                onChange={(e) => setNewBeatText(e.target.value)}
              />
              <button onClick={handleAddBeat}>+ Add Beat</button>
            </div>

            <hr style={{ margin: "15px 0" }} />

            <ChapterSummary
              novelId={novelId}
              chapter={chapter}
              isCollapsed={isSummaryCollapsed}
              onToggleCollapse={onToggleSummaryCollapse}
              onUpdateSummary={onUpdateChapterSummary}
              onCopySummaryPrompt={onCopySummaryPrompt}
            />
          </div>
        );
      }

      // --- NovelEditorView Component ---
      function NovelEditorView({
        novel,
        onBack,
        onUpdateNovel,
        onDeleteNovel,
        // Chapter Actions
        onAddChapter,
        onDeleteChapter,
        onMoveChapter,
        onUpdateChapterTitle,
        // Beat Actions
        onAddBeat,
        onDeleteBeat,
        onMoveBeat,
        onUpdateBeatText, // Still needed for saving edit beat modal
        onUpdateGeneratedText, // Needed for clear & saving edit gen text modal
        // Summary Actions
        onUpdateChapterSummary,
        // Other
        onExportNovel,
        onShowPrompt,
        onShowTemplateEditor,
        summaryCollapseStates,
        onToggleSummaryCollapse,
        onCopySummaryPrompt,
        onEditBeat,
        onShowEditGeneratedTextModal,
        handleViewNovelText,
      }) {
        const [exportFeedback, setExportFeedback] = useState(false);
        const [chapterFilter, setChapterFilter] = useState("all");

        const handleExport = () => {
          onExportNovel(novel.id)
            .then(() => {
              setExportFeedback(true);
              setTimeout(() => setExportFeedback(false), 1500);
            })
            .catch((err) => {
              console.error("Export failed:", err);
              alert("Export failed. See console for details.");
            });
        };

        const filteredChapters = useMemo(() => {
          if (chapterFilter === "all") {
            return novel.chapters;
          }
          return novel.chapters.filter((ch) => ch.id === chapterFilter);
        }, [novel.chapters, chapterFilter]);

        return (
          <div className="view" id="novelEditorView">
            <button onClick={onBack}>← Back to Novel List</button>
            <div className="novel-title-edit">
              <input
                type="text"
                id="editNovelTitle"
                value={novel.title || ""}
                onChange={(e) =>
                  onUpdateNovel(novel.id, { title: e.target.value })
                }
              />
            </div>
            <div className="import-export-area">
              <button onClick={handleExport}>Export Novel</button>
              <button onClick={() => onShowTemplateEditor(novel.id)}>
                Edit Continue Prompt Template
              </button>
              <button onClick={() => handleViewNovelText(novel.id)}>
                View Novel Text
              </button>
              <div className="feedback-container">
                <FeedbackMessage show={exportFeedback} />
              </div>
            </div>
            <div className="chapter-filter">
              <label htmlFor="chapterFilter">Show chapter: </label>
              <select
                id="chapterFilter"
                value={chapterFilter}
                onChange={(e) => setChapterFilter(e.target.value)}
              >
                <option value="all">All Chapters</option>
                {novel.chapters.map((ch, index) => (
                  <option key={ch.id} value={ch.id}>
                    {ch.title || `Chapter ${index + 1}`}
                  </option>
                ))}
              </select>
            </div>
            <button
              className="delete-btn"
              onClick={() => onDeleteNovel(novel.id)}
            >
              Delete This Novel
            </button>
            <hr />

            <div id="chaptersContainer">
              {filteredChapters.length === 0 &&
                chapterFilter !== "all" &&
                novel.chapters.length > 0 && (
                  <p style={{ fontStyle: "italic", color: "#888" }}>
                    Chapter not found. Showing all chapters. Select "All
                    Chapters" above.
                  </p>
                )}
              {filteredChapters.length > 0
                ? filteredChapters.map((chapter) => {
                    const originalIndex = novel.chapters.findIndex(
                      (ch) => ch.id === chapter.id
                    );
                    return (
                      <Chapter
                        key={chapter.id}
                        novelId={novel.id}
                        chapter={chapter}
                        chapterIndex={originalIndex}
                        totalChapters={novel.chapters.length}
                        onUpdateChapterTitle={onUpdateChapterTitle}
                        onDeleteChapter={onDeleteChapter}
                        onMoveChapter={onMoveChapter}
                        onAddBeat={onAddBeat}
                        // onUpdateBeatText removed
                        onUpdateGeneratedText={onUpdateGeneratedText} // Pass down for clear button
                        onDeleteBeat={onDeleteBeat}
                        onMoveBeat={onMoveBeat}
                        onShowPrompt={onShowPrompt}
                        isSummaryCollapsed={
                          typeof summaryCollapseStates[chapter.id] !==
                            "undefined" &&
                          summaryCollapseStates[chapter.id] !== null
                            ? summaryCollapseStates[chapter.id]
                            : true
                        }
                        onToggleSummaryCollapse={onToggleSummaryCollapse}
                        onUpdateChapterSummary={onUpdateChapterSummary}
                        onCopySummaryPrompt={onCopySummaryPrompt}
                        onEditBeat={onEditBeat}
                        onShowEditGeneratedTextModal={
                          onShowEditGeneratedTextModal
                        } // **** PASS DOWN ****
                      />
                    );
                  })
                : chapterFilter === "all" && (
                    <p>No chapters yet. Click "+ Add New Chapter" below.</p>
                  )}
            </div>

            <button onClick={() => onAddChapter(novel.id)}>
              + Add New Chapter
            </button>
          </div>
        );
      }

      // --- NovelListView Component ---
      function NovelListView({
        novels,
        onCreateNovel,
        onOpenNovel,
        onDeleteNovel,
        onImportNovel,
      }) {
        const [newNovelTitle, setNewNovelTitle] = useState("");
        const [importVisible, setImportVisible] = useState(false);
        const [importText, setImportText] = useState("");

        const handleCreate = () => {
          onCreateNovel(newNovelTitle);
          setNewNovelTitle(""); // Clear input
        };

        const handleImport = () => {
          if (!importText.trim()) {
            alert("Please paste the exported novel markdown content first.");
            return;
          }
          onImportNovel(importText);
          setImportText("");
          setImportVisible(false);
        };

        const toggleImport = () => {
          setImportVisible(!importVisible);
          if (importVisible) {
            // If closing
            setImportText("");
          }
        };

        const sortedNovels = useMemo(() => {
          const novelsArray = Array.isArray(novels) ? novels : [];
          return [...novelsArray].sort((a, b) =>
            (a.title || "").localeCompare(b.title || "")
          );
        }, [novels]);

        return (
          <div className="view" id="novelListView">
            <h2>Novels</h2>
            <ul id="novelList">
              {sortedNovels.length === 0 ? (
                <li>No novels found. Create one below or import one.</li>
              ) : (
                sortedNovels.map((novel) => (
                  <li key={novel.id}>
                    <span
                      className="novel-item-title"
                      onClick={() => onOpenNovel(novel.id)}
                    >
                      {novel.title || "Untitled Novel"}
                    </span>
                    <div>
                      <button onClick={() => onOpenNovel(novel.id)}>
                        Open
                      </button>
                      <button
                        className="delete-btn"
                        onClick={() => onDeleteNovel(novel.id)}
                      >
                        Delete
                      </button>
                    </div>
                  </li>
                ))
              )}
            </ul>
            <div>
              <input
                type="text"
                id="newNovelTitle"
                placeholder="New Novel Title"
                value={newNovelTitle}
                onChange={(e) => setNewNovelTitle(e.target.value)}
              />
              <button onClick={handleCreate}>Create New Novel</button>
              <button onClick={toggleImport}>
                {importVisible ? "Cancel Import" : "Import Novel"}
              </button>
            </div>

            {importVisible && (
              <div className="import-area show">
                <textarea
                  id="importText"
                  placeholder="Paste exported novel markdown here..."
                  value={importText}
                  onChange={(e) => setImportText(e.target.value)}
                ></textarea>
                <button onClick={handleImport}>Import</button>
                <button className="secondary-btn" onClick={toggleImport}>
                  Cancel
                </button>
              </div>
            )}
          </div>
        );
      }

      // --- Main App Component ---
      function App() {
        const [novels, setNovels] = useState([]);
        const [currentView, setCurrentView] = useState("list"); // 'list' or 'editor'
        const [currentNovelId, setCurrentNovelId] = useState(null);
        // **** Modal content now holds type AND data ****
        const [modalContent, setModalContent] = useState(null); // { type: 'prompt'|'template'|'export'|'editBeat'|'editGeneratedText', data: ... }
        const [summaryCollapseStates, setSummaryCollapseStates] = useState({});

        // --- Load initial data ---
        useEffect(() => {
          // Load Novels
          const storedNovels = localStorage.getItem(LS_KEY);
          let loadedNovels = [];
          if (storedNovels) {
            try {
              loadedNovels = JSON.parse(storedNovels);
              if (!Array.isArray(loadedNovels)) {
                console.warn("Loaded novels data is not an array, resetting.");
                loadedNovels = [];
              }
              // Basic validation/migration (ensure arrays/fields exist)
              loadedNovels.forEach((novel) => {
                if (typeof novel !== "object" || novel === null) return; // Skip invalid entries
                novel.id = novel.id || generateId();
                novel.title = novel.title || "Untitled Novel";
                novel.template =
                  novel.template === undefined ? null : novel.template;
                novel.chapters = Array.isArray(novel.chapters)
                  ? novel.chapters
                  : [];
                novel.chapters.forEach((chapter) => {
                  if (typeof chapter !== "object" || chapter === null) return;
                  chapter.id = chapter.id || generateId();
                  chapter.title = chapter.title || "Untitled Chapter";
                  chapter.summary = chapter.summary || "";
                  chapter.sceneBeats = Array.isArray(chapter.sceneBeats)
                    ? chapter.sceneBeats
                    : [];
                  chapter.sceneBeats.forEach((beat) => {
                    if (typeof beat !== "object" || beat === null) return;
                    beat.id = beat.id || generateId();
                    beat.text = beat.text || "";
                    beat.generatedText = beat.generatedText || "";
                  });
                });
              });
            } catch (e) {
              console.error("Error parsing novels from local storage:", e);
              loadedNovels = [];
            }
          }
          setNovels(loadedNovels);

          // Load Summary Collapse States
          const storedStates = localStorage.getItem(LS_SUMMARY_STATE_KEY);
          try {
            const loadedStates = JSON.parse(storedStates || "{}");
            setSummaryCollapseStates(
              typeof loadedStates === "object" && loadedStates !== null
                ? loadedStates
                : {}
            );
          } catch (e) {
            console.error("Error parsing summary states:", e);
            setSummaryCollapseStates({});
          }
        }, []);

        // --- Save data to local storage on change ---
        useEffect(() => {
          if (Array.isArray(novels)) {
            try {
              localStorage.setItem(LS_KEY, JSON.stringify(novels));
            } catch (e) {
              console.error("Error saving novels:", e);
              alert("Error saving novel data. Local storage might be full.");
            }
          }
        }, [novels]);

        useEffect(() => {
          try {
            localStorage.setItem(
              LS_SUMMARY_STATE_KEY,
              JSON.stringify(summaryCollapseStates)
            );
          } catch (e) {
            console.error("Error saving summary states:", e);
          }
        }, [summaryCollapseStates]);

        // --- State Update Helper ---
        const updateNovels = (updateFn) => {
          setNovels((prevNovels) => {
            const currentNovels = Array.isArray(prevNovels) ? prevNovels : [];
            return updateFn(currentNovels);
          });
        };

        // --- Novel Actions ---
        const handleCreateNovel = (title) => {
          const newNovel = {
            id: generateId(),
            title: title.trim() || "Untitled Novel",
            template: null,
            chapters: [],
          };
          updateNovels((prev) => [...prev, newNovel]);
          setCurrentNovelId(newNovel.id);
          setCurrentView("editor");
        };
        const handleOpenNovel = (id) => {
          setCurrentNovelId(id);
          setCurrentView("editor");
        };
        const handleDeleteNovel = (id) => {
          const novelToDelete = novels.find((n) => n.id === id);
          if (!novelToDelete) return;
          if (
            confirm(
              `Are you sure you want to delete the novel "${
                novelToDelete.title || "Untitled Novel"
              }"? This action cannot be undone.`
            )
          ) {
            updateNovels((prev) => prev.filter((novel) => novel.id !== id));
            if (currentNovelId === id) {
              setCurrentView("list");
              setCurrentNovelId(null);
            }
            setSummaryCollapseStates((prevStates) => {
              const newStates = { ...prevStates };
              if (Array.isArray(novelToDelete.chapters)) {
                novelToDelete.chapters.forEach((ch) => delete newStates[ch.id]);
              }
              return newStates;
            });
          }
        };
        const handleUpdateNovel = (id, updates) => {
          updateNovels((prev) =>
            prev.map((novel) =>
              novel.id === id ? { ...novel, ...updates } : novel
            )
          );
        };
        const handleBackToList = () => {
          setCurrentView("list");
          setCurrentNovelId(null);
        };

        // --- Chapter Actions ---
        const handleAddChapter = (novelId) => {
          const newChapter = {
            id: generateId(),
            title: "",
            sceneBeats: [],
            summary: "",
          };
          updateNovels((prev) =>
            prev.map((novel) => {
              if (novel.id === novelId) {
                const currentChapters = Array.isArray(novel.chapters)
                  ? novel.chapters
                  : [];
                newChapter.title = `Chapter ${currentChapters.length + 1}`;
                return { ...novel, chapters: [...currentChapters, newChapter] };
              }
              return novel;
            })
          );
        };
        const handleDeleteChapter = (novelId, chapterId) => {
          const novel = novels.find((n) => n.id === novelId);
          const chapter = findChapeter(novel, chapterId);
          if (!novel || !chapter) return;
          if (
            confirm(
              `Are you sure you want to delete "${
                chapter.title || "this chapter"
              }" and all its scene beats?`
            )
          ) {
            updateNovels((prev) =>
              prev.map((n) => {
                if (n.id === novelId) {
                  const currentChapters = Array.isArray(n.chapters)
                    ? n.chapters
                    : [];
                  return {
                    ...n,
                    chapters: currentChapters.filter(
                      (ch) => ch.id !== chapterId
                    ),
                  };
                }
                return n;
              })
            );
            setSummaryCollapseStates((prevStates) => {
              const newStates = { ...prevStates };
              delete newStates[chapterId];
              return newStates;
            });
          }
        };
        const handleUpdateChapterTitle = (novelId, chapterId, newTitle) => {
          updateNovels((prev) =>
            prev.map((n) => {
              if (n.id === novelId) {
                const currentChapters = Array.isArray(n.chapters)
                  ? n.chapters
                  : [];
                return {
                  ...n,
                  chapters: currentChapters.map((ch) =>
                    ch.id === chapterId
                      ? { ...ch, title: newTitle.trim() || "Untitled Chapter" }
                      : ch
                  ),
                };
              }
              return n;
            })
          );
        };
        const handleMoveChapter = (novelId, chapterId, direction) => {
          updateNovels((prev) =>
            prev.map((n) => {
              if (n.id === novelId) {
                const currentChapters = Array.isArray(n.chapters)
                  ? n.chapters
                  : [];
                const chapters = [...currentChapters];
                const index = chapters.findIndex((ch) => ch.id === chapterId);
                if (index === -1) return n;
                const newIndex = index + direction;
                if (newIndex < 0 || newIndex >= chapters.length) return n;
                [chapters[index], chapters[newIndex]] = [
                  chapters[newIndex],
                  chapters[index],
                ];
                return { ...n, chapters };
              }
              return n;
            })
          );
        };

        // --- Scene Beat Actions ---
        const handleAddBeat = (novelId, chapterId, text) => {
          const newBeat = {
            id: generateId(),
            text: text.trim(),
            generatedText: "",
          };
          updateNovels((prev) =>
            prev.map((n) => {
              if (n.id === novelId) {
                const currentChapters = Array.isArray(n.chapters)
                  ? n.chapters
                  : [];
                return {
                  ...n,
                  chapters: currentChapters.map((ch) => {
                    if (ch.id === chapterId) {
                      const currentBeats = Array.isArray(ch.sceneBeats)
                        ? ch.sceneBeats
                        : [];
                      return { ...ch, sceneBeats: [...currentBeats, newBeat] };
                    }
                    return ch;
                  }),
                };
              }
              return n;
            })
          );
        };

        // Trigger Edit Beat Modal
        const handleEditBeat = (novelId, chapterId, beatId) => {
          const novel = novels.find((n) => n.id === novelId);
          const chapter = findChapeter(novel, chapterId);
          const beat = chapter.sceneBeats.find((b) => b.id === beatId);
          if (!beat) return;
          setModalContent({
            type: "editBeat",
            data: { novelId, chapterId, beatId, text: beat.text || "" },
          });
        };

        // Save Edited Beat Text (called from EditBeatModal)
        const handleSaveBeatEdit = (novelId, chapterId, beatId, newText) => {
          handleUpdateBeatText(novelId, chapterId, beatId, newText);
          handleCloseModal();
        };

        const handleDeleteBeat = (novelId, chapterId, beatId) => {
          if (confirm("Are you sure you want to delete this scene beat?")) {
            updateNovels((prev) =>
              prev.map((n) => {
                if (n.id === novelId) {
                  const currentChapters = Array.isArray(n.chapters)
                    ? n.chapters
                    : [];
                  return {
                    ...n,
                    chapters: currentChapters.map((ch) => {
                      if (ch.id === chapterId) {
                        const currentBeats = Array.isArray(ch.sceneBeats)
                          ? ch.sceneBeats
                          : [];
                        return {
                          ...ch,
                          sceneBeats: currentBeats.filter(
                            (b) => b.id !== beatId
                          ),
                        };
                      }
                      return ch;
                    }),
                  };
                }
                return n;
              })
            );
          }
        };

        // Update Beat Instruction Text (used by save edit modal)
        const handleUpdateBeatText = (novelId, chapterId, beatId, newText) => {
          updateNovels((prev) =>
            prev.map((n) => {
              if (n.id === novelId) {
                const currentChapters = Array.isArray(n.chapters)
                  ? n.chapters
                  : [];
                return {
                  ...n,
                  chapters: currentChapters.map((ch) => {
                    if (ch.id === chapterId) {
                      const currentBeats = Array.isArray(ch.sceneBeats)
                        ? ch.sceneBeats
                        : [];
                      return {
                        ...ch,
                        sceneBeats: currentBeats.map((b) =>
                          b.id === beatId ? { ...b, text: newText } : b
                        ),
                      };
                    }
                    return ch;
                  }),
                };
              }
              return n;
            })
          );
        };

        // Update Generated Text (used by clear button & save edit modal)
        const handleUpdateGeneratedText = (
          novelId,
          chapterId,
          beatId,
          genText
        ) => {
          updateNovels((prev) =>
            prev.map((n) => {
              if (n.id === novelId) {
                const currentChapters = Array.isArray(n.chapters)
                  ? n.chapters
                  : [];
                return {
                  ...n,
                  chapters: currentChapters.map((ch) => {
                    if (ch.id === chapterId) {
                      const currentBeats = Array.isArray(ch.sceneBeats)
                        ? ch.sceneBeats
                        : [];
                      return {
                        ...ch,
                        sceneBeats: currentBeats.map((b) =>
                          b.id === beatId ? { ...b, generatedText: genText } : b
                        ),
                      };
                    }
                    return ch;
                  }),
                };
              }
              return n;
            })
          );
        };

        const handleMoveBeat = (novelId, chapterId, beatId, direction) => {
          updateNovels((prev) =>
            prev.map((n) => {
              if (n.id === novelId) {
                const currentChapters = Array.isArray(n.chapters)
                  ? n.chapters
                  : [];
                return {
                  ...n,
                  chapters: currentChapters.map((ch) => {
                    if (ch.id === chapterId) {
                      const currentBeats = Array.isArray(ch.sceneBeats)
                        ? ch.sceneBeats
                        : [];
                      const beats = [...currentBeats];
                      const index = beats.findIndex((b) => b.id === beatId);
                      if (index === -1) return ch;
                      const newIndex = index + direction;
                      if (newIndex < 0 || newIndex >= beats.length) return ch;
                      [beats[index], beats[newIndex]] = [
                        beats[newIndex],
                        beats[index],
                      ];
                      return { ...ch, sceneBeats: beats };
                    }
                    return ch;
                  }),
                };
              }
              return n;
            })
          );
        };

        // --- Summary Actions ---
        const handleUpdateChapterSummary = (
          novelId,
          chapterId,
          summaryText
        ) => {
          updateNovels((prev) =>
            prev.map((n) => {
              if (n.id === novelId) {
                const currentChapters = Array.isArray(n.chapters)
                  ? n.chapters
                  : [];
                return {
                  ...n,
                  chapters: currentChapters.map((ch) =>
                    ch.id === chapterId ? { ...ch, summary: summaryText } : ch
                  ),
                };
              }
              return n;
            })
          );
        };
        const handleToggleSummaryCollapse = (chapterId) => {
          setSummaryCollapseStates((prevStates) => {
            const currentState =
              typeof prevStates[chapterId] !== "undefined" &&
              prevStates[chapterId] !== null
                ? prevStates[chapterId]
                : true; // Default collapsed
            return { ...prevStates, [chapterId]: !currentState };
          });
        };

        // --- Prompt Generation (Existing - unchanged) ---
        const generatePromptText = (novelId, chapterId, beatId) => {
          const novel = novels.find((n) => n.id === novelId);
          if (!novel || !Array.isArray(novel.chapters))
            return { error: "Novel or chapters not found/invalid" };
          const chapterIndex = novel.chapters.findIndex(
            (ch) => ch.id === chapterId
          );
          const chapter = novel.chapters[chapterIndex];
          if (!chapter || !Array.isArray(chapter.sceneBeats))
            return { error: "Chapter or scene beats not found/invalid" };
          const beatIndex = chapter.sceneBeats.findIndex(
            (b) => b.id === beatId
          );
          const beat = chapter.sceneBeats[beatIndex];
          if (beatIndex === -1 || !beat)
            return { error: "Scene beat not found" };

          let storySoFar = "";
          const maxContextLength = 10000;

          // Previous chapters context
          for (let i = 0; i < chapterIndex; i++) {
            const prevChapter = novel.chapters[i];
            if (!prevChapter || !Array.isArray(prevChapter.sceneBeats))
              continue;
            let chapterContext = "";
            if (prevChapter.summary) {
              chapterContext = `Summary of Chapter ${i + 1}: ${
                prevChapter.title || "Untitled"
              }\n${prevChapter.summary}\n\n`;
            } else {
              const prevChapterText = prevChapter.sceneBeats
                .map((b) => b.generatedText || "")
                .filter(Boolean)
                .join("\n\n");
              if (prevChapterText) {
                chapterContext = `Content from Chapter ${i + 1}: ${
                  prevChapter.title || "Untitled"
                }\n${prevChapterText}\n\n`;
              }
            }
            if (
              storySoFar.length + chapterContext.length <
              maxContextLength * 1.2
            ) {
              storySoFar += chapterContext;
            } else break; // Stop adding chapters if context gets too long
          }

          // Previous beats in current chapter
          for (let i = 0; i < beatIndex; i++) {
            const prevBeat = chapter.sceneBeats[i];
            if (prevBeat && prevBeat.generatedText) {
              const beatText = prevBeat.generatedText + "\n\n";
              if (
                storySoFar.length + beatText.length <
                maxContextLength * 1.2
              ) {
                storySoFar += beatText;
              } else break; // Stop adding beats if context gets too long
            }
          }

          // Truncate if needed
          if (storySoFar.length > maxContextLength) {
            const excess = storySoFar.length - maxContextLength;
            storySoFar =
              `... (trimmed ${excess} characters)\n` + storySoFar.slice(excess);
          }
          storySoFar = storySoFar.trim();

          const template = getEffectiveTemplate(novel);
          const instructionsText = beat.text || "";
          let prompt = template.replace(
            "{storySoFar}",
            storySoFar || "This is the beginning of the story."
          );
          prompt = prompt.replace("{instructions}", instructionsText);
          return { prompt: prompt.trim() };
        };

        // --- Modal Handling ---
        const handleShowPrompt = (novelId, chapterId, beatId) => {
          const { prompt, error } = generatePromptText(
            novelId,
            chapterId,
            beatId
          );
          if (error) {
            alert(`Error generating prompt: ${error}`);
            return;
          }
          setModalContent({ type: "prompt", data: { text: prompt } });
        };
        const handleShowTemplateEditor = (novelId) => {
          const novel = novels.find((n) => n.id === novelId);
          if (!novel) return;
          setModalContent({
            type: "template",
            data: {
              novelId: novel.id,
              currentTemplate: getEffectiveTemplate(novel),
            },
          });
        };
        const handleShowExportModal = (exportText) => {
          setModalContent({ type: "export", data: { text: exportText } });
        };

        // **** NEW: Trigger Edit Generated Text Modal ****
        const handleShowEditGeneratedTextModal = (
          novelId,
          chapterId,
          beatId,
          generatedText
        ) => {
          setModalContent({
            type: "editGeneratedText",
            data: {
              novelId,
              chapterId,
              beatId,
              generatedText: generatedText || "",
            }, // Ensure text is not null/undefined
          });
        };

        const handleCloseModal = () => {
          setModalContent(null);
        };

        const handleSaveTemplate = (novelId, newTemplate) => {
          const templateToSave =
            newTemplate.trim() !== DEFAULT_PROMPT_TEMPLATE.trim()
              ? newTemplate
              : null;
          handleUpdateNovel(novelId, { template: templateToSave });
          handleCloseModal();
        };

        // Save Edited Generated Text
        const handleSaveGeneratedText = (
          novelId,
          chapterId,
          beatId,
          newText
        ) => {
          handleUpdateGeneratedText(novelId, chapterId, beatId, newText);
          handleCloseModal();
        };

        // --- Copy Actions ---
        const handleCopyPromptFromModal = (text) => {
          return copyToClipboard(text);
        };
        const handleCopySummaryPrompt = (novelId, chapterId) => {
          const novel = novels.find((n) => n.id === novelId);
          const chapter = findChapeter(novel, chapterId);
          if (!chapter || !Array.isArray(chapter.sceneBeats))
            return Promise.reject(
              new Error("Chapter or scene beats not found/invalid")
            );
          const chapterText = chapter.sceneBeats
            .map((beat) => beat.generatedText || "")
            .filter(Boolean)
            .join("\n\n");
          if (!chapterText) {
            alert("No generated content in this chapter to summarize.");
            return Promise.reject(new Error("No content to summarize"));
          }
          const prompt = `Please write a concise summary of the following chapter content:\n\n${chapterText}`;
          return copyToClipboard(prompt);
        };

        // --- Import / Export ---
        const handleExportNovel = (novelId) => {
          return new Promise((resolve, reject) => {
            const novel = novels.find((n) => n.id === novelId);
            if (!novel) return reject(new Error("Novel not found"));
            let markdown = `# ${novel.title || "Untitled Novel"}\n\n`;
            markdown += `### Template\n\n${getEffectiveTemplate(novel)}\n\n`;
            const currentChapters = Array.isArray(novel.chapters)
              ? novel.chapters
              : [];
            currentChapters.forEach((chapter, chapterIndex) => {
              markdown += `## ${
                chapter.title || `Chapter ${chapterIndex + 1}`
              }\n\n`;
              if (chapter.summary) {
                markdown += `### Summary\n\n${chapter.summary}\n\n`;
              }
              markdown += `### Scene Beats\n\n`;
              const currentBeats = Array.isArray(chapter.sceneBeats)
                ? chapter.sceneBeats
                : [];
              currentBeats.forEach((beat, beatIndex) => {
                markdown += `#### Beat ${beatIndex + 1}\n\n`;
                markdown += `**Scene Description:**\n${beat.text || ""}\n\n`;
                markdown += `**Generated Content:**\n${
                  beat.generatedText || ""
                }\n\n`;
              });
            });
            handleShowExportModal(markdown.trim());
            resolve();
          });
        };
        const handleImportNovel = (text) => {
          try {
            const novel = {
              id: generateId(),
              title: "Imported Novel",
              template: null,
              chapters: [],
            };
            const lines = text.split("\n");
            let currentChapter = null;
            let currentBeat = null;
            let readingMode = null; // null | 'summary' | 'description' | 'generated' | 'template'
            let accumulatingText = "";

            const finishAccumulatingText = () => {
              const content = accumulatingText.trim();
              if (readingMode === "template") {
                novel.template =
                  content && content !== DEFAULT_PROMPT_TEMPLATE
                    ? content
                    : null;
              } else if (readingMode === "summary" && currentChapter) {
                currentChapter.summary = content;
              } else if (readingMode === "description" && currentBeat) {
                currentBeat.text = content;
              } else if (readingMode === "generated" && currentBeat) {
                currentBeat.generatedText = content;
              }
              accumulatingText = "";
            };

            lines.forEach((line) => {
              const trimmedLine = line.trim();
              if (trimmedLine.startsWith("# ")) {
                finishAccumulatingText();
                novel.title =
                  trimmedLine.substring(2).trim() || "Imported Novel";
                readingMode = null;
              } else if (trimmedLine.startsWith("## ")) {
                finishAccumulatingText();
                currentChapter = {
                  id: generateId(),
                  title: trimmedLine.substring(3).trim(),
                  summary: "",
                  sceneBeats: [],
                };
                novel.chapters.push(currentChapter);
                currentBeat = null;
                readingMode = null;
              } else if (trimmedLine === "### Template") {
                finishAccumulatingText();
                readingMode = "template";
              } else if (trimmedLine === "### Summary" && currentChapter) {
                finishAccumulatingText();
                readingMode = "summary";
              } else if (trimmedLine === "### Scene Beats" && currentChapter) {
                finishAccumulatingText();
                readingMode = null;
              } else if (
                trimmedLine.startsWith("#### Beat") &&
                currentChapter
              ) {
                finishAccumulatingText();
                currentBeat = { id: generateId(), text: "", generatedText: "" };
                currentChapter.sceneBeats.push(currentBeat);
                readingMode = null;
              } else if (
                trimmedLine === "**Scene Description:**" &&
                currentBeat
              ) {
                finishAccumulatingText();
                readingMode = "description";
              } else if (
                trimmedLine === "**Generated Content:**" &&
                currentBeat
              ) {
                finishAccumulatingText();
                readingMode = "generated";
              } else {
                // Only accumulate if we are in a known reading mode or just after a header
                if (
                  readingMode ||
                  line.startsWith(" ") ||
                  line.startsWith("\t") ||
                  (accumulatingText && line)
                ) {
                  accumulatingText += line + "\n";
                } else if (trimmedLine) {
                  // If it's not whitespace and not a header, start accumulating (e.g. first line of template/summary)
                  accumulatingText += line + "\n";
                }
              }
            });
            finishAccumulatingText(); // Finish last section

            if (
              !novel.title ||
              ((!Array.isArray(novel.chapters) ||
                novel.chapters.length === 0) &&
                !novel.template)
            ) {
              console.warn("Imported text might be incomplete or invalid.");
            }
            if (Array.isArray(novel.chapters)) {
              novel.chapters.forEach((ch) => {
                ch.sceneBeats = Array.isArray(ch.sceneBeats)
                  ? ch.sceneBeats
                  : [];
              });
            } else {
              novel.chapters = [];
            }
            updateNovels((prev) => [...prev, novel]);
          } catch (e) {
            console.error("Import error:", e);
            alert(
              "Error importing novel. Please check the format.\n\n" + e.message
            );
          }
        };

        // --- Generate clean novel text (content only, no instructions or summaries) ---
        const generateNovelText = (novelId) => {
          return new Promise((resolve, reject) => {
            const novel = novels.find((n) => n.id === novelId);
            if (!novel) return reject(new Error("Novel not found"));

            let novelText = `${novel.title || "Untitled Novel"}\n\n`;

            const currentChapters = Array.isArray(novel.chapters)
              ? novel.chapters
              : [];

            currentChapters.forEach((chapter, chapterIndex) => {
              novelText += `${
                chapter.title || `Chapter ${chapterIndex + 1}`
              }\n\n`;

              const currentBeats = Array.isArray(chapter.sceneBeats)
                ? chapter.sceneBeats
                : [];

              const chapterContent = currentBeats
                .map((beat) => beat.generatedText || "")
                .filter(Boolean)
                .join("\n\n");

              novelText += `${chapterContent}\n\n`;
            });

            resolve(novelText.trim());
          });
        };

        // --- Handle View Novel Text (trigger for the new view text modal) ---
        const handleViewNovelText = (novelId) => {
          generateNovelText(novelId)
            .then((novelText) => {
              setModalContent({ type: "novelText", data: { text: novelText } });
            })
            .catch((err) => {
              console.error("Error generating novel text:", err);
              alert("Error generating novel text. See console for details.");
            });
        };

        // --- Current Novel Data ---
        const currentNovel = useMemo(() => {
          if (!Array.isArray(novels)) return null;
          return novels.find((n) => n.id === currentNovelId) || null;
        }, [novels, currentNovelId]);

        // --- Render Logic ---
        return (
          <div className="container">
            <h1>NovelTokenToken</h1>

            {currentView === "list" && (
              <NovelListView
                novels={novels}
                onCreateNovel={handleCreateNovel}
                onOpenNovel={handleOpenNovel}
                onDeleteNovel={handleDeleteNovel}
                onImportNovel={handleImportNovel}
              />
            )}

            {currentView === "editor" && currentNovel && (
              <NovelEditorView
                novel={currentNovel}
                onBack={handleBackToList}
                onUpdateNovel={handleUpdateNovel}
                onDeleteNovel={handleDeleteNovel}
                onAddChapter={handleAddChapter}
                onDeleteChapter={handleDeleteChapter}
                onMoveChapter={handleMoveChapter}
                onUpdateChapterTitle={handleUpdateChapterTitle}
                onAddBeat={handleAddBeat}
                onDeleteBeat={handleDeleteBeat}
                onMoveBeat={handleMoveBeat}
                onUpdateBeatText={handleUpdateBeatText} // Pass down for saving beat edit
                onUpdateGeneratedText={handleUpdateGeneratedText} // Pass down for clear/saving gen text edit
                onUpdateChapterSummary={handleUpdateChapterSummary}
                onExportNovel={handleExportNovel}
                onShowPrompt={handleShowPrompt}
                onShowTemplateEditor={handleShowTemplateEditor}
                summaryCollapseStates={summaryCollapseStates}
                onToggleSummaryCollapse={handleToggleSummaryCollapse}
                onCopySummaryPrompt={handleCopySummaryPrompt}
                onEditBeat={handleEditBeat} // Pass down edit beat trigger
                onShowEditGeneratedTextModal={handleShowEditGeneratedTextModal}
                handleViewNovelText={handleViewNovelText} // Pass the function that shows the novel text modal
              />
            )}

            {/* Render Modals */}
            {modalContent && modalContent.type === "prompt" && (
              <PromptModal
                promptText={modalContent.data && modalContent.data.text}
                onClose={handleCloseModal}
                onCopy={handleCopyPromptFromModal}
              />
            )}
            {modalContent && modalContent.type === "template" && (
              <TemplateEditorModal
                novelId={modalContent.data && modalContent.data.novelId}
                currentTemplate={
                  modalContent.data && modalContent.data.currentTemplate
                }
                onClose={handleCloseModal}
                onSave={handleSaveTemplate}
                defaultTemplate={DEFAULT_PROMPT_TEMPLATE}
              />
            )}
            {modalContent && modalContent.type === "export" && (
              <ExportModal
                exportText={modalContent.data && modalContent.data.text}
                onClose={handleCloseModal}
                onCopy={handleCopyPromptFromModal}
              />
            )}
            {modalContent && modalContent.type === "editBeat" && (
              <EditBeatModal
                // Pass necessary data and save handler
                beatText={modalContent.data && modalContent.data.text}
                onClose={handleCloseModal}
                onSave={(editedText) =>
                  handleSaveBeatEdit(
                    modalContent.data.novelId,
                    modalContent.data.chapterId,
                    modalContent.data.beatId,
                    editedText
                  )
                }
              />
            )}
            {/* Render Edit Generated Text Modal */}
            {modalContent && modalContent.type === "editGeneratedText" && (
              <EditGeneratedTextModal
                generatedText={
                  modalContent.data && modalContent.data.generatedText
                }
                onClose={handleCloseModal}
                onSave={(editedText) =>
                  handleSaveGeneratedText(
                    modalContent.data.novelId,
                    modalContent.data.chapterId,
                    modalContent.data.beatId,
                    editedText
                  )
                }
              />
            )}
            {modalContent && modalContent.type === "novelText" && (
              <NovelTextModal
                novelText={modalContent.data && modalContent.data.text}
                onClose={handleCloseModal}
                onCopy={handleCopyPromptFromModal}
              />
            )}
          </div>
        );
      }

      // --- Specific Modal Components ---
      function PromptModal({ promptText, onClose, onCopy }) {
        const [copyFeedback, setCopyFeedback] = useState("");
        const handleCopy = () => {
          onCopy(promptText)
            .then(() => {
              setCopyFeedback("Copied!");
              setTimeout(() => setCopyFeedback(""), 1500);
            })
            .catch((err) => {
              console.error("Copy failed:", err);
              setCopyFeedback("Error");
              setTimeout(() => setCopyFeedback(""), 1500);
            });
        };
        return (
          <Modal
            title="Scene Beat Prompt"
            onClose={onClose}
            footer={
              <React.Fragment>
                <button onClick={handleCopy} disabled={!!copyFeedback}>
                  {copyFeedback || "Copy to Clipboard"}
                </button>
                <button className="secondary-btn" onClick={onClose}>
                  Close
                </button>
              </React.Fragment>
            }
          >
            <textarea
              className="prompt-textarea"
              value={promptText || ""}
              readOnly
            />
          </Modal>
        );
      }

      function TemplateEditorModal({
        novelId,
        currentTemplate,
        onClose,
        onSave,
        defaultTemplate,
      }) {
        const [templateText, setTemplateText] = useState(currentTemplate || "");
        useEffect(() => {
          setTemplateText(currentTemplate || "");
        }, [currentTemplate]);
        const handleSave = () => {
          onSave(novelId, templateText);
        };
        const handleReset = () => {
          if (
            confirm(
              "Are you sure you want to reset the template in the editor to the default? This won't save until you click 'Save Template'."
            )
          ) {
            setTemplateText(defaultTemplate);
          }
        };
        return (
          <Modal
            title="Edit Continue Prompt Template"
            onClose={onClose}
            footer={
              <React.Fragment>
                <button onClick={handleSave}>Save Template</button>
                <button className="secondary-btn" onClick={handleReset}>
                  Reset to Default
                </button>
                <button className="secondary-btn" onClick={onClose}>
                  Close
                </button>
              </React.Fragment>
            }
          >
            <textarea
              id="templateTextarea"
              className="prompt-textarea"
              value={templateText}
              onChange={(e) => setTemplateText(e.target.value)}
            />
            <div className="template-help">
              <p>Use these placeholders:</p>
              <ul>
                <li>
                  <code>{"{storySoFar}"}</code> - Context from previous
                  chapters/beats.
                </li>
                <li>
                  <code>{"{instructions}"}</code> - The text from the current
                  scene beat description.
                </li>
              </ul>
            </div>
          </Modal>
        );
      }

      function ExportModal({ exportText, onClose, onCopy }) {
        const [copyFeedback, setCopyFeedback] = useState(false);
        const handleCopy = () => {
          onCopy(exportText)
            .then(() => {
              setCopyFeedback(true);
              setTimeout(() => setCopyFeedback(false), 1500);
            })
            .catch((err) => {
              console.error("Copy failed:", err);
              alert("Failed to copy. See console for details.");
            });
        };
        return (
          <Modal
            title="Export Preview"
            onClose={onClose}
            footer={
              <React.Fragment>
                <button onClick={handleCopy} disabled={copyFeedback}>
                  {copyFeedback ? "Copied!" : "Copy to Clipboard"}
                </button>
                <button className="secondary-btn" onClick={onClose}>
                  Close
                </button>
              </React.Fragment>
            }
          >
            <textarea
              className="prompt-textarea"
              value={exportText || ""}
              readOnly
            />
          </Modal>
        );
      }

      // --- Edit Beat Modal Component ---
      function EditBeatModal({ beatText, onClose, onSave }) {
        const [editedText, setEditedText] = useState(beatText || "");
        const handleSave = () => {
          onSave(editedText);
        };
        return (
          <Modal
            title="Edit Scene Beat Instruction"
            onClose={onClose}
            footer={
              <React.Fragment>
                <button onClick={handleSave}>Save Changes</button>
                <button className="secondary-btn" onClick={onClose}>
                  Cancel
                </button>
              </React.Fragment>
            }
          >
            <textarea
              className="prompt-textarea" // Reuse class
              value={editedText}
              onChange={(e) => setEditedText(e.target.value)}
              placeholder="Enter scene beat instruction..."
              autoFocus // Focus textarea on open
            />
          </Modal>
        );
      }

      // --- Edit Generated Text Modal Component ---
      function EditGeneratedTextModal({ generatedText, onClose, onSave }) {
        const [editedText, setEditedText] = useState(generatedText || "");
        const handleSave = () => {
          onSave(editedText);
        };

        return (
          <Modal
            title="Edit Generated Content"
            onClose={onClose}
            footer={
              <React.Fragment>
                <button onClick={handleSave}>Save Changes</button>
                <button className="secondary-btn" onClick={onClose}>
                  Cancel
                </button>
              </React.Fragment>
            }
          >
            <textarea
              className="prompt-textarea" // Reuse class, maybe adjust min-height if needed
              value={editedText}
              onChange={(e) => setEditedText(e.target.value)}
              placeholder="Edit the generated content..."
              autoFocus // Focus textarea on open
            />
          </Modal>
        );
      }

      function NovelTextModal({ novelText, onClose, onCopy }) {
        const [copyFeedback, setCopyFeedback] = useState(false);

        const handleCopy = () => {
          onCopy(novelText)
            .then(() => {
              setCopyFeedback(true);
              setTimeout(() => setCopyFeedback(false), 1500);
            })
            .catch((err) => {
              console.error("Copy failed:", err);
              alert("Failed to copy. See console for details.");
            });
        };

        return (
          <Modal
            title="Novel Text"
            onClose={onClose}
            footer={
              <React.Fragment>
                <button onClick={handleCopy} disabled={copyFeedback}>
                  {copyFeedback ? "Copied!" : "Copy to Clipboard"}
                </button>
                <button className="secondary-btn" onClick={onClose}>
                  Close
                </button>
              </React.Fragment>
            }
          >
            <div style={{ maxHeight: "70vh", overflow: "auto" }}>
              <div
                style={{
                  whiteSpace: "pre-wrap",
                  fontFamily: "serif",
                  lineHeight: "1.6",
                  padding: "15px",
                  backgroundColor: "#fcfcfc",
                  border: "1px solid #eee",
                  borderRadius: "4px",
                }}
              >
                {novelText || "No content available"}
              </div>
            </div>
          </Modal>
        );
      }

      // --- Render the App ---
      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<App />);
    </script>
  </body>
</html>
